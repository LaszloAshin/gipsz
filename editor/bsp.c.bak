#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "bsp.h"
#include "ed.h"
#include "gr.h"
#include <SDL/SDL.h>

typedef struct {
  int x, y;
  int s;
} vertex_t;

struct node_s;

typedef struct line_s {
  int a, b;
  int s;
  int c, l, r, n;
  int pd;
  struct node_s *neigh;
} line_t;

typedef struct node_s {
  line_t *p;
  unsigned alloc, n;
  struct node_s *l, *r;
} node_t;

typedef struct sector_s {
  int s;
  node_t *n;
} sector_t;

static struct {
  vertex_t *p;
  unsigned alloc, n;
} vc;

static struct {
  sector_t *p;
  unsigned alloc, n;
} sc;

static node_t *root = NULL;

static int bspGetVertex(int x, int y) {
  int i;
  for (i = 0; i < vc.n; ++i)
    if (vc.p[i].x == x && vc.p[i].y == y)
      return i;
  return -1;
}

static int bspAddVertex(int x, int y) {
  int i = bspGetVertex(x, y);
  if (i >= 0) return i;
  if (vc.n == vc.alloc) {
    vc.alloc *= 2;
    vertex_t *p = (vertex_t *)malloc(vc.alloc * sizeof(vertex_t));
    if (p == NULL) return -1;
    for (i = 0; i < vc.n; ++i) p[i] = vc.p[i];
    free(vc.p);
    vc.p = p;
  }
  vc.p[vc.n].x = x;
  vc.p[vc.n].y = y;
  return vc.n++;
}

static int bspAddSector() {
  if (sc.n == sc.alloc) {
    sc.alloc *= 2;
    sector_t *p = (sector_t *)malloc(sc.alloc * sizeof(sector_t));
    if (p == NULL) return -1;
    int i;
    for (i = 0; i < sc.n; ++i) p[i] = sc.p[i];
    free(sc.p);
    sc.p = p;
  }
  sc.p[sc.n].s = 0;
  sc.p[sc.n].n = NULL;
  return sc.n++;
}

static void bspDuplicateTree(node_t *n) {
  int i;

  void bspDuplicateNode(node_t *n, node_t **p) {
    *p = (node_t *)malloc(sizeof(node_t));
    if (*p == NULL) return;
    if (n->l == NULL && n->r == NULL) {
      if ((i = bspAddSector()) < 0) return;
      sc.p[i].n = *p;
    }
    (*p)->alloc = (*p)->n = 0;
    (*p)->p = NULL;
    if (n->l != NULL) bspDuplicateNode(n->l, &(*p)->l); else (*p)->l = NULL;
    if (n->r != NULL) bspDuplicateNode(n->r, &(*p)->r); else (*p)->r = NULL;
  }

  bspDuplicateNode(n->l, &n->r);
}

static node_t *bspGetNodeForSector(int s) {
  if (!s) return NULL;
  int i;
  for (i = 0; i < sc.n; ++i)
    if (sc.p[i].s == s)
      return sc.p[i].n;
  for (i = 0; i < sc.n; ++i)
    if (!sc.p[i].s) {
      sc.p[i].s = s;
      return sc.p[i].n;
    }
  node_t *p = (node_t *)malloc(sizeof(node_t));
  if (p == NULL) return p;
  p->alloc = p->n = 0;
  p->p = NULL;
  p->l = root;
  bspDuplicateTree(p);
  root = p;
  return bspGetNodeForSector(s);
}

int bspAddLine(unsigned s, int x1, int y1, int x2, int y2) {
  int a = bspAddVertex(x1, y1);
  int b = bspAddVertex(x2, y2);
  node_t *n = bspGetNodeForSector(s);
  if (n == NULL) return -1;
  if (a < 0 || b < 0) return -1;
  unsigned i;
  if (n->n == n->alloc) {
    if (!n->alloc)
      n->alloc = 4;
    else
      n->alloc *= 2;
    line_t *p = (line_t *)malloc(n->alloc * sizeof(line_t));
    if (p == NULL) return -1;
    for (i = 0; i < n->n; ++i) p[i] = n->p[i];
    if (n->p != NULL) free(n->p);
    n->p = p;
  }
  n->p[n->n].a = a;
  n->p[n->n].b = b;
  n->p[n->n].s = s;
  n->p[n->n].neigh = NULL;
  unsigned j;
  node_t *p;
  for (i = 0; i < sc.n; ++i)
    if (sc.p[i].s != s) {
      p = sc.p[i].n;
      for (j = 0; j < p->n; ++j)
        if (p->p[j].a == b && p->p[j].b == a) {
          n->p[n->n].neigh = p;
          p->p[j].neigh = n;
          break;
        }
      if (n->p[n->n].neigh != NULL) break;
    }
  return n->n++;
}

static int bspIntersect(vertex_t p1, vertex_t p2, vertex_t p3, vertex_t p4, vertex_t *mp) {
  double dx21 = p2.x - p1.x;
  double dx43 = p4.x - p3.x;
  double dy21 = p2.y - p1.y;
  double dy43 = p4.y - p3.y;
  double dy13 = p1.y - p3.y;
  double t = dy43 * dx21 - dy21 * dx43;
  if (!t) return 0; /* parallel */
  double y, x = (dx21 * (dy13 * dx43 + dy43 * p3.x) - (dy21 * dx43 * p1.x)) / t;
  if (abs(dx21) > abs(dx43)) {
    if (dx21)
      y = p1.y + (x - p1.x) * dy21 / dx21;
    else
      return 0;
  } else if (dx43)
    y = p3.y + (x - p3.x) * dy43 / dx43;
  else
    return 0;
  mp->x = round(x);
  mp->y = round(y);
  return 1;
}

static void bspShowSub(node_t *n) {
  static int i;
  if (n->l != NULL) bspShowSub(n->l);
  if (n->r != NULL) bspShowSub(n->r);
  if (n->p != NULL) {
    grSetColor(n->p[0].c | 3);
    for (i = 0; i < n->n; ++i)
      edVector(vc.p[n->p[i].a].x, vc.p[n->p[i].a].y, vc.p[n->p[i].b].x, vc.p[n->p[i].b].y);
  }
}

void bspShow() {
  int i;

  if (root != NULL) bspShowSub(root);
  grSetColor(255);
  for (i = 0; i < vc.n; ++i) edVertex(vc.p[i].x, vc.p[i].y);
}

int bspCountNodes() {
  int bspCountNodesSub(node_t *n) {
    if (n == NULL) return 0;
    return 1 + bspCountNodesSub(n->l) + bspCountNodesSub(n->r);
  }

  return bspCountNodesSub(root);
}

static void bspSortVerteces(unsigned *p, unsigned n) {
  if (n < 2) return;
  unsigned i, j, k;
  if (abs(vc.p[p[1]].x - vc.p[p[0]].x) > abs(vc.p[p[1]].y - vc.p[p[0]].y)) {
    for (i = 0; i < n; ++i) {
      k = i;
      for (j = i + 1; j < n; ++j)
        if (vc.p[p[j]].x > vc.p[p[k]].x) k = j;
      if (k != i) {
        j = p[k];
        p[k] = p[i];
        p[i] = j;
      }
    }
  } else {
    for (i = 0; i < n; ++i) {
      k = i;
      for (j = i + 1; j < n; ++j)
        if (vc.p[p[j]].y > vc.p[p[k]].y) k = j;
      if (k != i) {
        j = p[k];
        p[k] = p[i];
        p[i] = j;
      }
    }
  }
}

static int bspAreConnected(node_t *n, unsigned a, unsigned b) {
  unsigned i;
  for (i = 0; i < n->n; ++i)
    if ((n->p[i].a == a && n->p[i].b == b))
      return !0;
  return 0;
}

static int bspALine(node_t *n, unsigned a) {
  unsigned i, j = 0;
  for (i = 0; i < n->n; ++i)
    if (n->p[i].a == a) {
      for (; j < n->n; ++j)
        if (n->p[j].b == a && n->p[i].s == n->p[j].s) {
          ++j;
          break;
        }
      if (j == n->n) return n->p[i].s;
    }
  return 0;
}

static int bspBLine(node_t *n, unsigned b) {
  unsigned i, j = 0;
  for (i = 0; i < n->n; ++i)
    if (n->p[i].b == b) {
      for (; j < n->n; ++j)
        if (n->p[j].a == b && n->p[i].s == n->p[j].s) {
          ++j;
          break;
        }
      if (j == n->n) return n->p[i].s;
    }
  return 0;
}

static int bspGetPair(node_t *n, unsigned l) {
  node_t *p = n->p[l].neigh;
  unsigned i;
  for (i = 0; i < p->n; ++i)
    if (p->p[i].a == n->p[l].b && p->p[i].b == n->p[l].a) {
      if (p->p[i].neigh != n) printf("pair neighje mashova mutat\n");
      return i;
    }
  return -1;
}

static void bspNoticePair(node_t *n, unsigned l, node_t *p) {
  int i = bspGetPair(n, l);
  if (i != -1) n->p[l].neigh->p[i].neigh = p;
}

void bspCleanTree() {
  void bspCleanSub(node_t **n) {
    if ((*n)->l != NULL) bspCleanSub(&(*n)->l);
    if ((*n)->r != NULL) bspCleanSub(&(*n)->r);
    if ((*n)->l == NULL && (*n)->r == NULL && !(*n)->n) {
      free(*n);
      *n = NULL;
    }
  }

  if (root != NULL) bspCleanSub(&root);
}

//int bspLoad(FILE *f);

void bspBuildTree() {
  int i, j, l, e, r, f, t;
  int dx1, dy1, dx2, dy2, da, db, mina, maxa;
  vertex_t v;
  node_t *ne;

  void bspBuildSub(node_t *n) {
    if (n == NULL || n->n < 2) return;
//    printf("bspBuildSub(): %d\n", n->n);
    for (i = 0; i < n->n; ++i) {
      n->p[i].l = n->p[i].r = n->p[i].n = 0;
      dx1 = vc.p[n->p[i].b].x - vc.p[n->p[i].a].x;
      dy1 = vc.p[n->p[i].b].y - vc.p[n->p[i].a].y;
      for (j = 0; j < n->n; ++j) {
        dx2 = vc.p[n->p[j].a].x - vc.p[n->p[i].a].x;
        dy2 = vc.p[n->p[j].a].y - vc.p[n->p[i].a].y;
        da = dy1 * dx2 - dy2 * dx1;
        dx2 = vc.p[n->p[j].b].x - vc.p[n->p[i].a].x;
        dy2 = vc.p[n->p[j].b].y - vc.p[n->p[i].a].y;
        db = dy1 * dx2 - dy2 * dx1;
        if ((da < 0 && db > 0) || (da > 0 && db < 0)) {
          ++n->p[i].n;
          continue;
        }
        if (da < 0) ++n->p[i].r; else if (da > 0) ++n->p[i].l;
        if (db < 0) ++n->p[i].r; else if (db > 0) ++n->p[i].l;
      }
    }
    j = 0;
    for (i = 1; i < n->n; ++i) {
      da = abs(n->p[i].r - n->p[i].l);
      db = abs(n->p[j].r - n->p[j].l);
      if ((n->p[i].l || n->p[i].n) && ((da < db) || ((da == db) && (n->p[i].n < n->p[j].n)))) j = i;
    }
    dx1 = vc.p[n->p[j].b].x - vc.p[n->p[j].a].x;
    dy1 = vc.p[n->p[j].b].y - vc.p[n->p[j].a].y;
    l = e = r = f = 0;
    for (i = 0; i < vc.n; ++i) vc.p[i].s = 0;
    mina = maxa = 0;
    for (i = 0; i < n->n; ++i) {
      n->p[i].l = n->p[i].r = 0;
      dx2 = vc.p[n->p[i].a].x - vc.p[n->p[j].a].x;
      dy2 = vc.p[n->p[i].a].y - vc.p[n->p[j].a].y;
      da = dy1 * dx2 - dy2 * dx1;
      dx2 = vc.p[n->p[i].b].x - vc.p[n->p[j].a].x;
      dy2 = vc.p[n->p[i].b].y - vc.p[n->p[j].a].y;
      db = dy1 * dx2 - dy2 * dx1;
      if (da < mina) mina = da;
      if (db < mina) mina = db;
      if (da > maxa) maxa = da;
      if (db > maxa) maxa = db;
      if (!da && !vc.p[n->p[i].a].s) {
        ++f;
        ++vc.p[n->p[i].a].s;
      }
      if (!db && !vc.p[n->p[i].b].s) {
        ++f;
        ++vc.p[n->p[i].b].s;
      }
      if (!da && !db) {
        dx2 = vc.p[n->p[i].a].x - vc.p[n->p[i].b].x;
        dy2 = vc.p[n->p[i].a].y - vc.p[n->p[i].b].y;
        da = dy1 * dy2 + dx1 * dx2;
      }
      if ((da < 0 && db <= 0) || (da <= 0 && db < 0)) {
        ++n->p[i].r;
        ++r;
        continue;
      }
      if ((da > 0 && db >= 0) || (da >= 0 && db > 0)) {
        ++n->p[i].l;
        ++l;
        continue;
      }
      ++e;
    }
    if (!l && !e) return;
    
    f += e;
    /* here f tells us how many verteces are on the nodeline */
//    printf("f=%d mina=%d maxa=%d\n", f, mina, maxa);
    if (mina >= 10 || maxa <= 10) return;

    n->l = (node_t *)malloc(sizeof(node_t));
    if (n->l == NULL) return;
    n->l->l = n->l->r = NULL;
    n->l->alloc = l + e + f;
    n->l->p = (line_t *)malloc(n->l->alloc * sizeof(line_t));
    if (n->l->p == NULL) {
      free(n->l);
      n->l = NULL;
      return;
    }
    n->l->n = 0;

    n->r = (node_t *)malloc(sizeof(node_t));
    if (n->r == NULL) {
      free(n->l->p);
      free(n->l);
      n->l = NULL;
      return;
    }
    n->r->l = n->r->r = NULL;
    n->r->alloc = r + e + f;
    n->r->p = (line_t *)malloc(n->r->alloc * sizeof(line_t));
    if (n->r->p == NULL) {
      free(n->l->p);
      free(n->l);
      n->l = NULL;
      free(n->r);
      n->r = NULL;
      return;
    }
    n->r->n = 0;

    l = r = 0;
    for (i = 0; i < n->n; ++i) {
      if (n->p[i].r) {
        n->r->p[r++] = n->p[i];
        if (n->p[i].neigh != NULL) bspNoticePair(n, i, n->r);
        continue;
      }
      if (n->p[i].l) {
        n->l->p[l++] = n->p[i];
        if (n->p[i].neigh != NULL) bspNoticePair(n, i, n->l);
        continue;
      }
      dx2 = vc.p[n->p[i].a].x - vc.p[n->p[j].a].x;
      dy2 = vc.p[n->p[i].a].y - vc.p[n->p[j].a].y;
      da = dy1 * dx2 - dy2 * dx1;
      /* this helps to find mistakes: */ v.x = v.y = 0;
      bspIntersect(vc.p[n->p[j].a], vc.p[n->p[j].b], vc.p[n->p[i].a], vc.p[n->p[i].b], &v);
      if ((e = bspGetVertex(v.x, v.y)) == -1) e = bspAddVertex(v.x, v.y);
      vc.p[e].s = 1;
      ne = n->p[i].neigh;
      t = (ne != NULL) ? bspGetPair(n, i) : -1;
      if (t >= 0) {
        /* make sure we have enough space on the neigh node */
        if (ne->p[t].a != e && ne->p[t].b != e && ne->n == ne->alloc) {
          ne->alloc *= 2;
          line_t *p = (line_t *)malloc(ne->alloc * sizeof(line_t));
          unsigned j;
          for (j = 0; j < ne->n; ++j) p[j] = ne->p[j];
          free(ne->p);
          ne->p = p;
        }
        ne->p[t] = ne->p[--ne->n];
      }
      t = t != -1;
      if (da > 0) {
        if (n->p[i].a != e) {
          n->l->p[l].a = n->p[i].a;
          n->l->p[l].b = e;
          n->l->p[l].s = n->p[i].s;
          if (t) {
            n->l->p[l].neigh = ne;
            ne->p[ne->n].a = e;
            ne->p[ne->n].b = n->p[i].a;
            ne->p[ne->n].s = ne->p[0].s;
            ne->p[ne->n].neigh = n->l;
            ++ne->n;
          } else
            n->l->p[l].neigh = NULL;
          ++l;
        }
        if (n->p[i].b != e) {
          n->r->p[r].a = e;
          n->r->p[r].b = n->p[i].b;
          n->r->p[r].s = n->p[i].s;
          if (t) {
            n->r->p[r].neigh = ne;
            ne->p[ne->n].a = n->p[i].b;
            ne->p[ne->n].b = e;
            ne->p[ne->n].s = ne->p[0].s;
            ne->p[ne->n].neigh = n->r;
            ++ne->n;
          } else
            n->r->p[r].neigh = NULL;
          ++r;
        }
      } else {
        if (n->p[i].a != e) {
          n->r->p[r].a = n->p[i].a;
          n->r->p[r].b = e;
          n->r->p[r].s = n->p[i].s;
          if (t) {
            n->r->p[r].neigh = ne;
            ne->p[ne->n].a = e;
            ne->p[ne->n].b = n->p[i].a;
            ne->p[ne->n].s = ne->p[0].s;
            ne->p[ne->n].neigh = n->r;
            ++ne->n;
          } else
            n->r->p[r].neigh = NULL;
          ++r;
        }
        if (n->p[i].b != e) {
          n->l->p[l].a = e;
          n->l->p[l].b = n->p[i].b;
          n->l->p[l].s = n->p[i].s;
          if (t) {
            n->l->p[l].neigh = ne;
            ne->p[ne->n].a = n->p[i].b;
            ne->p[ne->n].b = e;
            ne->p[ne->n].s = ne->p[0].s;
            ne->p[ne->n].neigh = n->l;
            ++ne->n;
          } else
            n->l->p[l].neigh = NULL;
          ++l;
        }
      }
    }

    free(n->p);
    n->p = NULL;

    /* fontos! */
    n->r->n = r;
    n->l->n = l;

    int p[f];
    t = 0;
    for (i = 0; i < vc.n; ++i) if (vc.p[i].s) p[t++] = i;
    bspSortVerteces(p, t);
    dx2 = vc.p[p[0]].x - vc.p[p[t-1]].x;
    dy2 = vc.p[p[0]].y - vc.p[p[t-1]].y;
    --t;
    i = 0;
    if (dy1 * dy2 + dx1 * dx2 > 0) {
      do {
        da = bspALine(n->r, p[i]);
        db = bspBLine(n->l, p[i]);
        ++i;
        j = 0;
        if (da && !bspAreConnected(n->r, p[i], p[i-1])) {
          n->r->p[n->r->n].a = p[i];
          n->r->p[n->r->n].b = p[i-1];
          n->r->p[n->r->n].s = da;
          n->r->p[n->r->n].neigh = NULL;
          ++n->r->n;
          ++j;
        }
        if (db && !bspAreConnected(n->l, p[i-1], p[i])) {
          n->l->p[n->l->n].a = p[i-1];
          n->l->p[n->l->n].b = p[i];
          n->l->p[n->l->n].s = db;
          if (j) {
            n->r->p[n->r->n-1].neigh = n->l;
            n->l->p[n->l->n].neigh = n->r;
          } else
            n->l->p[n->l->n].neigh = NULL;
          ++n->l->n;
        }
      } while (i < t);
    } else {
      do {
        da = bspALine(n->l, p[i]);
        db = bspBLine(n->r, p[i]);
        ++i;
        j = 0;
        if (da && !bspAreConnected(n->l, p[i], p[i-1])) {
          n->l->p[n->l->n].a = p[i];
          n->l->p[n->l->n].b = p[i-1];
          n->l->p[n->l->n].s = da;
          n->l->p[n->l->n].neigh = NULL;
          ++n->l->n;
          ++j;
        }
        if (db && !bspAreConnected(n->r, p[i-1], p[i])) {
          n->r->p[n->r->n].a = p[i-1];
          n->r->p[n->r->n].b = p[i];
          n->r->p[n->r->n].s = db;
          if (j) {
            n->r->p[n->r->n].neigh = n->l;
            n->l->p[n->l->n-1].neigh = n->r;
          } else
            n->r->p[n->r->n].neigh = NULL;
          ++n->r->n;
        }
      } while (i < t);
    }

    e = rand() | 3;
    for (i = 0; i < n->r->n; ++i) n->r->p[i].c = e;
    e = rand() | 3;
    for (i = 0; i < n->l->n; ++i) n->l->p[i].c = e;

    grBegin();
    bspShowSub(n);
    grEnd();
//    SDL_Delay(100);
    bspBuildSub(n->l);
    bspBuildSub(n->r);
    n->n = 0;
  }

  void bspBuildSearch(node_t *n) {
    if (!n->n) {
      if (n->l != NULL) bspBuildSearch(n->l);
      if (n->r != NULL) bspBuildSearch(n->r);
    } else {
      e = rand() | 3;
      for (i = 0; i < n->n; ++i) n->p[i].c = e;
      bspBuildSub(n);
    }
  }

  bspCleanTree();
  printf("bspBuildTree():\n vertex: %d\n", vc.n);
  if (root != NULL) bspBuildSearch(root);
  printf("bspBuildTree(): done\n");
  printf("bspCountNodes(): %d\n", bspCountNodes());
/*  FILE *fp = fopen("map.bsp", "rb");
  bspLoad(fp);
  fclose(fp);*/
}

int bspInit() {
  vc.alloc = 8;
  vc.p = (vertex_t *)malloc(vc.alloc * sizeof(vertex_t));
  if (vc.p == NULL) return 0;
  vc.n = 0;

  sc.alloc = 8;
  sc.p = (sector_t *)malloc(sc.alloc * sizeof(sector_t));
  if (sc.p == NULL) goto end1;
  sc.n = 1;

  root = (node_t *)malloc(sizeof(node_t));
  if (root == NULL) goto end2;
  root->l = root->r = NULL;
  root->alloc = 0;
  root->p = NULL;
  root->n = 0;

  sc.p[0].n = root;
  sc.p[0].s = 0;

  return !0;
 end2:
  free(sc.p);
 end1:
  free(vc.p);
  return 0;
}

void bspDone() {
  void bspDelNode(node_t *n) {
    if (n->l != NULL) bspDelNode(n->l);
    if (n->r != NULL) bspDelNode(n->r);
    if (n->p != NULL) free(n->p);
    free(n);
  }
  if (root != NULL) bspDelNode(root);
  free(sc.p);
  sc.n = sc.alloc = 0;
  free(vc.p);
  vc.n = vc.alloc = 0;
}

typedef struct {
  short x : 16;
  short y : 16;
} fvertex_t;

typedef struct {
  short a : 16;
  short b : 16;
  char flags : 8;
} fline_t;

int bspSave(FILE *f) {
  unsigned i, j, k;
  static const unsigned f32 = 0xffffffff;
  fvertex_t fv;
  fline_t fl;

  void bspSaveSub(node_t *n) {
    fwrite(&n->n, sizeof(int), 1, f);
    if (n->n) {
      j = n->p[0].a;
      for (i = 0; i < n->n; ++i) n->p[i].n = 0;
      k = 0;
      for (i = 0; i < n->n; ++i) {
        if (n->p[i].a == j && !n->p[i].n) {
          fl.a = n->p[i].a;
          fl.b = n->p[i].b;
          fl.flags = n->p[i].neigh != NULL;
          fwrite(&fl, sizeof(fline_t), 1, f);
          j = n->p[i].b;
          ++n->p[i].n;
          i = 0;
          ++k;
        }
      }
    }
    if (n->l != NULL) bspSaveSub(n->l); else fwrite(&f32, sizeof(int), 1, f);
    if (n->r != NULL) bspSaveSub(n->r); else fwrite(&f32, sizeof(int), 1, f);
  }

  fwrite(&vc.n, sizeof(int), 1, f);
  for (i = 0; i < vc.n; ++i) {
    fv.x = vc.p[i].x;
    fv.y = vc.p[i].y;
    fwrite(&fv, sizeof(fvertex_t), 1, f);
  }
  if (root != NULL) bspSaveSub(root);
  return !0;
}
/*
int bspLoad(FILE *f) {
  unsigned i, c;
  fvertex_t fv;
  fline_t fl;

  node_t *bspLoadSub() {
    fread(&i, sizeof(int), 1, f);
    if (i == 0xffffffff) return NULL;
    node_t *n = (node_t *)malloc(sizeof(node_t));
    if (n == NULL) return n;
    n->n = i;
    n->p = (line_t *)malloc(n->n * sizeof(line_t));
    c = rand();
    for (i = 0; i < n->n; ++i) {
      fread(&fl, sizeof(fline_t), 1, f);
      n->p[i].a = fl.a;
      n->p[i].b = fl.b;
      n->p[i].c = c;
    }
    n->l = bspLoadSub();
    n->r = bspLoadSub();
    return n;
  }

  if (root != NULL) free(root);
  if (vc.p != NULL) free(vc.p);
  fread(&vc.alloc, sizeof(int), 1, f);
  vc.p = (vertex_t *)malloc(vc.alloc * sizeof(vertex_t));
  vc.n = vc.alloc;
  for (i = 0; i < vc.n; ++i) {
    fread(&fv, sizeof(fvertex_t), 1, f);
    vc.p[i].x = fv.x;
    vc.p[i].y = fv.y;
  }
  root = bspLoadSub();
      
  return !0;
}
*/
